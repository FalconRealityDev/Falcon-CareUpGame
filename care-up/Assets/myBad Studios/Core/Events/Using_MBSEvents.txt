How to use MBSEvents
==========================

Most of my products are taking an event driven approach and as such I have a LOT
of events that I need to organise and keep track of. The biggest problem with events is
calling it when it is still null. Fortunately that is only a simple case of checking if
it's null before you invoke it. Simple, right? 

Now keep in mind that your project might have 50 or 150 events that you want to trigger
and in every single script where you trigger it from you first have to do that test...
The very first project I worked on made me realize that this is just plain stupid as it
wastes a LOT of my time rewriting the same code over and over and over. When I first 
started learning programming and got to the chapter where they asked "What is a function?"
they answered:
"Write a function in place of any code that you will have to write more than once"

Day one stuff. Don't duplicate code. So I applied that philosophy and write a function
to do the tests for me so now I just call the placeholder function instead of the event
itself and the problem is solved... except I now have to write one such function for each
of the 150 events in my project and all the functions are identical apart from what event
it takes as the argument. One such copy and paste operation for every function that test for
and uses the event and another copy paste operation for clearing the event leading to a
class filled with many, many, many duplicate lines of code with only a slight change in their
arguments. This soon became more tedious than testing the events one at a time.

This lead to the creation of the MBSEvents class. Simply put, it allows you to add any number
of events into a single variable, have that variable initialize all your events in advance, 
have that single variable clear all your events in one go and give you a single variable 
through which to call any number of events from any number of scritps without ever once having
to worry about manually checking if there are any responders listening to the event being triggered.

MBSEvents make life so simple when it comes to creating events, testing for null and cleaning
up that using them is no longer a chore. The thing that makes MBSEvents so incredibly
easy to use is the fact that your events no longer have unique names. Instead, they just go
into an array and you call them by their array index. But how does that make life easier?
Simple... you just use an enum as your array index and now, whenever you want to add a new
event to your project literally all you have to do is add an entry to the enum and you are done!

Your event is setup, it gets checked for null and it is cleared for you. All you did was add
one word to the enum and everything relating to your new event is already done for you.
THAT is what makes MBSEvents so simple to use!

Time for an example:
	public enum MyEnum { Action1, Action2, Action3 }
	public MBSEvents<MyEnum> MyActions = new MBSEvents<MyEnum>();

	void Start()
	{
		MyActions.Trigger(MyEnum.Action1);
		MyActions.AddEvent(MyEnum.Action2, Foo);
		MyActions.Trigger(MyEnum.Action2);
		MyActions.RemoveEvent(MyEnum.Action2, Foo);
	}

	void OnDestroy()
	{
		MyActions.ClearEvents();
	}

	void Foo(object source, MBSEvent data)
	{
		print("This got called");
	}

In the example above I triggered Action1 which is still null so it silently fails without throwing
any errors. I then set a responder for Action2 and call it successfully before manually removing
Foo as an event listener. You are free to add as many listeners as you want to any action and can
manually remove them as the need arises or, like in the OnDestroy function, you can remove all
listeneres from all events in one line of code.

I repeat what I said earlier... If you now have a new event you want to add to your project you
need only add a value to the MyEnum enum and you are ready to use that event any time you like.

Personally, I like creating a static class called Events inside of a script called Events.cs and
inside there I create static events for enums related to specific, related tasks. Personal preference

For example:

	public enum CharacterActions { Idle, Walk, Run, Jump, Melee1, Melee2, Die }
	public enum AIActions { Idle, Patrol, Alert, FindEthan }
	public enum GameActions { TriggerAlarm, CancelAlarm }

	static public class Events {
		static public MBSEvents<CharacterActions> CharActions;
		static public MBSEvents<AIActions> AIActions;
		static public MBSEvents<GameActions> GameActions;
	}

	public class MyCamera : MonoBehaviour
	{
		public flaot camera_FOV = 3of;
		public float last_spotted;
		bool on_alert = false;
	
		void Start()
		{
			Events.GameActions.AddEvent( GameActions.TriggerAlarm, OnAlarmTriggered);
			Events.GameActions.AddEvent( GameActions.CancelAlarm, OnAlarmCancelled);
		}

		void OnDestroy()
		{
			Events.GameActions.Removevent( GameActions.TriggerAlarm, OnAlarmTriggered);
			Events.GameActions.RemoveEvent( GameActions.CancelAlarm, OnAlarmCancelled);
		}

		void OnAlarmTriggered(object source, MBSEvent data)
		{
			on_alert = true;
		}

		void OnAlarmCancelled(object source, MBSEvent data)
		{
			on_alert = false;
		}

		void Update()
		{
			bool spotted = Ethan.InRangeOf(this) && Ethan.AngleFromCamera() < Camera_FOV;
			if (!on_alert && spotted)
			{
				Events.GameActions.Trigger(GameActions.TriggerAlarm);
				last_spotted = Time.time;
			} 

			if (on_alert && spotted)
			{
				last_spotted = Time.time;
			}

			if (on_alert && !spotted && Time.time - last_spotted > 30f)
			{
				Events.GameActions.Trigger(GameActions.CancelAlarm);
			}
		}
	}

Of course, you could place these events on individual instances of objects just as easily 
as using them statically like in the above example. It all dependso on your needs, of course.

You will notice that the function identities of the event responders match those of mbsEvent.
Please see Using_mbsEvent.txt for why this event is a fantastic choice for this class since it
is virtually universal in it's ability to pass two game objects and an unlimited number of
variables to your events. How to use mbsEvent is explained in detail in that readme document.

	MBSEvents Constructors
	------------------
	public MBSEvents<T> Foo = new MBSEvents<T>();
	* where T is an enum type

	mbsEvent Functions List
	------------------
	public void AddEvent( T action, mbsEventHandler response )
	public void RemoveEvent( T action, mbsEventHandler response )
	public void TriggerEvent( T action, object source = null, mbsEvent data = null )
	public void ClearEvents()

HOW TO USE MBSNotices
=====================
MBSNotices does exactly the same job as MBSEvents except it takes an Action with no parameters
as it's event responders instead of full blown events.

In the example given above you will notice that I don't make use of any of the variables
passed to the event responders (in fact, I just pass null instead of any values at all). 
In that example it would have made more sense to use MBSNotices instead of MBSEvents since 
you could have used this:

		void OnAlarmTriggered()
		{
			on_alert = true;
		}

...in stead of...

		void OnAlarmTriggered(object source, MBSEvent data)
		{
			on_alert = true;
		}

The two classes work identically apart from a few changes to the function names:

	MBSNotices Constructors
	-----------------------
	public MBSNotices<T> Foo = new MBSNotices<T>();
	* where T is an enum type

	mbsEvent Functions List
	-----------------------
	public void Add( T action, mbsEventHandler response )
	public void Remove( T action, mbsEventHandler response )
	public void Trigger( T action, object source = null, mbsEvent data = null )
	public void Clear()

