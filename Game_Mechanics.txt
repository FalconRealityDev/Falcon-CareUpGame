Scene is a functional unit, that includes everything for a single scenario to work. 
In order for scene to be complete it needs to have GameLogic gameObject with scripts:

	1. CameraMode         - needed for switching between modes
		a. Free mode 		 - player can move freely, interact with anything
		b. ObjectPreview 	 - player 'Examines' an ExaminableObject, can rotate and zoom the item at the center of the screen, cannot do anything else until closes this mode
		c. SelectionDialogue - player selects one of several options when talking to a PersonObject or during AnimationSequence, cannot do anything except choosing an option
		d. ConfirmUI 		 - currently unused, intended to confirm actions like exiting scenes in old version, where additional pop up appears to confirm an action
		e. Cinematic 		 - player cannot do anything at all, player just looks at our fancy animations
		f. ItemControlsUI 	 - player started interacting with an InteractableObject, new UI is shown, cannot do anything until chooses an option
	2. HandsInventory 	  - needed for handling items in left/right hands
	3. CombinationManager - needed for handling combinations, requires an XML file with list of all possible combinations player can perform. 
	                      - Only combinations stated in XML file will be possible within a scene, any other item combinations will not count as a try of combination action.
	4. ActionManager	  - actual list of actions of a scenario, requires an XML file with a list of actions player needs to perform in order to complete a scene.
	5. Controls			  - script handles Mouse/Touch/Keyboard/Gamepad inputs
	6. GameTimer          - script counts time elapsed from the point when scene started.
	7. IngameMenu         - handling general UI that player can open within a scene.
	
Now we continue to an actual player. We always spawn a player as a prefab and always put a PlayerSpawn gameObject in a scene.
PlayerSpawn has one script attached ("PlayerSpawn") with a several fields.

	1. QuizName  	- quiz xml file name. Quiz mechanics in development
	2. PlayerPrefab - actual prefab of a player.
	3. InfoList 	- list of a theory which will be available during certain scene. Each list item has two fields - visual button name and actual prefab name that contains theory.
	
PlayerPositions is an important gameObject to contain in a scene. It contains objects that are functioning as positions where player can move.
Each object must have a Collider which will work as a trigger to move to that location (trigger is activated by clicking on it while playing). 
Object requires "WalkToGroup" script to work properly. This script has fields for a Position and Rotation that will be applied to a player after interacting with it.
As a child of this object - there should be a TextMesh or something else that will be activated when player hovers over a collider and deactivated otherwise to mark the location.
	
We need some UI objects for a scene to be complete.
	
	1. ItemDescription  	- UI that is attached to a cursor and shows a description of an InteractableObject when player is hovering over the object.
	2. ItemControls 		- UI that appears when player starts interacting with InteractableObject (clicks on the object). Contains multiple buttons for different actions possible to perform.
	
Another object that is required - currently is called _Dev, it has a single script in it, that was considered to be used as a cheat for testing to see the action player needs to perform, 
but now it is included in a gameplay. Script is called "Cheat_CurrentAction" and has a single parameter which is fading time for a text in UI.

Last object is just EventSystem that is required by Unity3d for all UI to work properly.

Shortly, it is strongly considered to copy all these objects from a complete scene to a new one and then make changes like changing action/combination xml file names, theory list, etc.
Final list of required objects:

	1. GameLogic
	2. PlayerSpawn 
	3. PlayerPositions
	4. ItemDescription 
	5. ItemControls
	6. _Dev
	7. EventSystem
	
----------------------------------------------------------------------------------------------------

Above this line is basic objects that are necessary for the game to work. Now we'll discuss what's needed for a separate scene to operate.
Scene generally will consist of two types of items.

	1. Static environment - objects, that are purely for visuals. Nothing can be done with them, nothing special. Just put wherever and set up to look best. This includes lightning and sound.
	2. Interactable Objects - these are the objects that are, generally, put on the table in front of the player so player can interact with them in various ways.
	
Interactable Objects must be inside a folder called "InteractableObjects", which is a gameObject without any parameters (Transform is pure Zero and no components attached) and is there 
purely to be a container for all interactable objects. These objects can be different type with different scripts attached to them.
InteractableObject has several parameters within UnityEditor that will persist through all object types:
	
	1. Description 		 - is a string field, which works as a visual name, that is shown in ItemDescription when player hovers over an object.
	2. MultipleMesh 	 - a boolean field, that is created to switch between different shaders. Some objects will consist of multiple meshes that will screw up default highlight 
						 - shader for single-meshed objects. For such objects - activate this field to switch to different shader. If it still looks horrible - contact Gijs or Alex.
	3. DescriptionOffset - this field is obsolete now, when ItemDescription is attached to a mouse cursor. Before - ui was spawned at the center of the object and this was created
						 - to move the ItemDescription to a proper position.

Before listing all possible types I need to say, that all scripts that will be listed are inherited from an "InteractableObject" script which is created for 
shader changes (highlighting an item when hovering over it) and setting up ItemDescription when hovering over it. 

	1. PickableObject 			- base script for items that could be picked up and held in a hand. The object will be moved to a different position in Unity hierarchy.
								- picking is sent to an ActionManager and tracked, but has no penalties at all.
		a. HoldAnimationID 			- pickable objects have a single parameter, that is used to play a certain hand animation that will fit an object.
	2. ExaminableObject 		- script for the items that needs to be 'examined' (i.e. looking closely at bottle of medicine to check date or look in patient records to read info).
								- by default, examining an item - puts it in the center of a screen with separate controls where player is able to rotate it and zoom in/out.
								- but the item could be examined in other ways too. Audio examine is obsolete, but was intended to replace all examining mechanics, so just a sound would be played instead.
								- another way to examine is with a holding animation. If it is possible - player can pick up an object, then examine - an animation is played moving object close to camera.
								- no controls are possible during examining until player closes this examining mode and returns to normal play.
		a. AudioExamine  			- boolean, switches examining mode for an object. Does nothing at this point, do not check it.
		b. AnimationExamine 		- boolean, switches examining mode for an object. Plays a certain animation that moves object close to a camera.
		c. ViewSettings 			- several options for a normal examining mode
			I.  Distance From Camera    - does what it says, applied at a start of examining.
			II. Rotation Sensetivity    - does what it says, modifies speed of rotation with cursor during examining mode.
		d. State 					- functional parameter. This parameter is passed to ActionManager when examining is performed. 
	3. UsableObject 			- object can be used in some way, without picking up. For example - cleaning hands with a hygiene pump. No parameters.
	4. PersonObject				- somewhat complicated script, because it will require having "PersonObjectPart" scripts attached to every single child with a collider. Generally,
								- 'persons' are complicated meshes with multiple body parts, that move and interact separately, that's why instead of putting a single collider on entire
								- model - we are putting smaller ones on different body parts, like head, arm, hand, etc. "PersonObjectPart" are just to be able to interact with the parent script.
								- Interacting with a PersonObject creates a 'Dialogue' where player can select a message to say. This action is sent to ActionManager.
		a. Dialogue XML 			- xml file name with all possible messages player can select during 'talking'.
		
Any specific object that needs to be programmed, generally, inherit these bases. But with nothing special - these scripts should be applied to objects. Objects must have a model and a collider. 
PickableObject must also have a RigidBody component in order to function properly gravity-wise.

----------------------------------------------------------------------------------------------------

ActionManager is very important part of setting up a scene. It is an XML file with a list of all actions that are needed to be performed in order to complete a scene when playing.
A single action in xml requires multiple additional fields

	1. description 		- this field works as a visual message on what to do in this step. The part before () is shown as a main part in Cheat_CurrentAction UI and the part within bracket 
						- is an additional part that is also shown in same UI after opening additional UI. There MUST be brackets OR next field for this extra part of description.
	2. fullDescription  - is an additional part as opposed to using brackets in "description" field.
	3. index 			- this field is necessary (and feels weird, i know) to order actions. Actions must be still ordered from top to bottom, so the only use for the index is
						- to allow several actions be performed in any order. For example if actions have indexes: 0, 1, 2, 2, 2, 3, 4.. - this means all actions with index 2 
						- can be done in any order ( but still strictly after 1 and before 3).
	4. audioHint   		- field that must contain audio file name, that is played when player asks for a hint.
	5. extra            - this field is used as an explanation on what was done wrong at this step at the EndScore scene in a WrongActions section.
	6. buttonText 		- this field is used only for "Use" and "UseOn" action types to change the "Use" default button text.
	7. points 			- this field is used to change the default value of an action (default: 1).
	8. type 			- most important field, that sets all the info for what should be done at this step.
		a. type="combine"	- combination type. this means that player needs to do something with object(s) while HOLDING them in hands. This always cooperates with CombinationManager.
							- This action automatically launches an animation, making a trigger "Combine <LeftHandObjectName> <RightHandObjectName>" active.
			I.  left="" 			- this must be an object name that should be held when combination occurs
			II. right=""			- this must be an object name that should be held when combination occurs (!order does not matter!)
		b. type="use"	    - use type. this action means player needs to interact with some item in a scene without picking it up. for example - cleaning hands with hygiene pump.
							- This action automatically launches an animation, making a trigger "Use <ObjectName>" active.
			I.  value=""   			- name of the object that needs to be used ( must have UsableObject script ).
		c. type="talk"		- talking to a PersonObject. Player needs to interact with PersonObject and select certain option. 
			I. 	topic=""			- the actual topic that must be selected from the dialogue options. only this topic will be correct.
		d. type="useOn"		- using object that is HELD in a hand on something, that is NOT HELD in a hand. Example: using needle on a trashcan in order to drop it in there.
							- This action automatically launches an animation, making a trigger "UseLeft/UseRight <HeldObjectName> <TargetObjectName>" active.
			I.	useItem="" 			- name of the object that is being held in a hand
			II. target=""			- name of the target object that will be selected
		e. type="examine"	- examining action. Checks item state when 'examine' action is selected. Item must have ExaminableObject script.
							- if animation mode selected - action automatically launches an animation, making a trigger "closeup_left/right" active. For closing trigger is "faraway_left/right".
			I.	exItem=""			- item name that will be examined.
			II.	expected=""			- this field is being compared with a State field in ExaminableObject script. If it matches - action is considered correct.
		f. type="pickUp"	- silent action that can be used, but is not noticeable in the game. Although gives reward points with sound if action is correct.
			I. 	itemPicked="" 		- the name of the object that should be picked up.
		d. type="sequenceStep" - selected sequence step, look more into sequence XML files. When player selects an option while in a sequence - it is considered this type.
			I. 	stepName=""			- name of the selected option. if this field matches - action is considered correct. 
			
----------------------------------------------------------------------------------------------------

Implementing animations is easy and their launch is pretty mush automated. All animations should be placed in PlayerAnimationController. Generally, it does not matter where you place them,
but for a good measure it's recommended to put them accordingly to a scene they are created for and action type they are supposed to show.
Generally, there are only 5 animation types.

	1. Hold animation 		- does not require any scripting or attaching scripts. Controller has two parameters: "LeftHandState" and "RightHandState" according to each hand.
							- depending on that parameter needed animation should be played from the entry of controller. (Transition: Entry -> animation).
							- Parameters are controlled outside, picking an item sets corresponding hand state to a HoldAnimationID field from PickableObject.
							- Adding hold animation is stupidly precise, just copy one-by-one all the settings from other hold animations, so everything is the same.
	2. Use Animations 		- are animations for the 'Use' action type ( when player holds nothing in hands and interacts with some object ). 
							- The trigger must always be "Use <ObjectName>". The animation itself must have "CinematicAnimation" script attached to it.
							- All the parameters from CinematicAnimation are for additional sound played during animation.
		a. audio 					- boolean to activate sound during animation
		b. audio file name 			- name of the file that will be played
		c. audio frame 				- frame of the animation, when sound will be launched
		d. position object name 	- name of the object for 3D positioning of the sound, generally should be at the object animations works with
		e. volume					- volume in percentages (1 = 100%)
	3. UseOn Animations 	- animations for 'UseOn' action type ( when player uses an item that is HELD in hand on something that is NOT held in hand ).
							- Trigger must always be "UseLeft/UseRight <HeldObjectName> <TargetObjectName>". The animation itself must have "AnimationUseOn" script attached to it.
							- There are no parameters, but usually these animations are being heavily scripted, extending AnimationUseOn script.
	4. Combine Animations 	- animations for "Combine" action type ( when player combines/decombines items that are being HELD in hands ). 
							- Trigger must always be "Combine <LeftHandObjectName> <RightHandObjectName>". Animation itself must have "AnimationCombine" script attached to it.
		a. combine frame 			- at this frame combination will occur, replacing entry objects with result objects. This is occurred in a different script.
	5. Animation Sequences 	- These animations always will require additional scripting, cuz all of them are unique. 
							- Triggers must always end with "Sequence" word, but can have any name you want, they are not launched automatically.
							- Animation itself can have "AnimationSequenceState" attached to it, but it will be replaced with a new script later, extending base one.
						   - It's only parameter must be a list of frame numbers, at which point animation will be paused and played will need to select correct dialogue option.
						
An impotant thing to mention. Due to Unity3d handling triggers very poorly, we need to create duplicate triggers, that should be name exactly same with addition of "S " at the start.
When any animation is launched both "Trigger" and "S Trigger" are being activated. So use normal one for 1st hand and "S " one for another hand.

Another smaller thing to mention. When ObjectName is require inside a trigger name, but there is not object - put "_" symbol instead. For example combinations does not always work with
two different object in left and right hands, but just one. In this situation Trigger will look like "Combine <LeftHandObjectName> _". This means right hand is empty. 